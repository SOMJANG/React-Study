"use strict";

var _object = _interopRequireDefault(require("object.assign"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _shallow = _interopRequireDefault(require("react-test-renderer/shallow"));

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _checkPropTypes2 = _interopRequireDefault(require("prop-types/checkPropTypes"));

var _reactIs = require("react-is");

var _enzyme = require("enzyme");

var _Utils = require("enzyme/build/Utils");

var _enzymeShallowEqual = _interopRequireDefault(require("enzyme-shallow-equal"));

var _enzymeAdapterUtils = require("enzyme-adapter-utils");

var _reflection = require("react-reconciler/reflection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HostRoot = 3;
var ClassComponent = 2;
var FragmentType = 10;
var FunctionalComponent = 1;
var HostPortal = 4;
var HostComponent = 5;
var HostText = 6;
var Mode = 11;
var ContextConsumerType = 12;
var ContextProviderType = 13;
var ForwardRefType = 14;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;

  while (node != null) {
    array.push(node);
    node = node.sibling;
  }

  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{
    i: 0,
    array: arr
  }];

  while (stack.length) {
    var n = stack.pop();

    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;

      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({
          i: 0,
          array: el
        });
        break;
      }

      result.push(el);
    }
  }

  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;
  var props = {
    children: children,
    containerInfo: containerInfo
  };
  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  } // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps


  var node = (0, _reflection.findCurrentFiberUsingSlowPath)(vnode);

  switch (node.tag) {
    case HostRoot:
      // 3
      return childrenToTree(node.child);

    case HostPortal:
      {
        // 4
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;
        var props = {
          containerInfo: containerInfo,
          children: children
        };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case FunctionalComponent:
      // 1
      return {
        nodeType: 'function',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };

    case HostComponent:
      {
        // 5
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'host',
          type: node.type,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: renderedNodes
        };
      }

    case HostText:
      // 6
      return node.memoizedProps;

    case FragmentType: // 10

    case Mode: // 11

    case ContextProviderType: // 13

    case ContextConsumerType:
      // 12
      return childrenToTree(node.child);

    case ForwardRefType:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: _objectSpread({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    default:
      throw new Error("Enzyme Internal Error: unknown node with tag ".concat(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }

  var children = nodeAndSiblingsArray(node);

  if (children.length === 0) {
    return null;
  }

  if (children.length === 1) {
    return _toTree(children[0]);
  }

  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;

  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  } // if the SFC returned null effectively, there is no host node.


  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom["default"].findDOMNode(item.instance);
    return null;
  };

  if (Array.isArray(node)) {
    return node.map(mapper);
  }

  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }

  return mapper(node);
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }

  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return {
    $$typeof: _reactIs.Element,
    type: type
  };
}

var eventOptions = {
  animation: true
};

var ReactSixteenThreeAdapter = /*#__PURE__*/function (_EnzymeAdapter) {
  _inherits(ReactSixteenThreeAdapter, _EnzymeAdapter);

  var _super = _createSuper(ReactSixteenThreeAdapter);

  function ReactSixteenThreeAdapter() {
    var _this;

    _classCallCheck(this, ReactSixteenThreeAdapter);

    _this = _super.call(this);
    var lifecycles = _this.options.lifecycles;
    _this.options = _objectSpread(_objectSpread({}, _this.options), {}, {
      enableComponentDidUpdateOnSetState: true,
      // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: _objectSpread(_objectSpread({}, lifecycles), {}, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: true
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        }
      })
    });
    return _this;
  }

  _createClass(ReactSixteenThreeAdapter, [{
    key: "createMountRenderer",
    value: function createMountRenderer(options) {
      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
      var attachTo = options.attachTo,
          hydrateIn = options.hydrateIn,
          wrappingComponentProps = options.wrappingComponentProps;
      var domNode = hydrateIn || attachTo || global.document.createElement('div');
      var instance = null;
      var adapter = this;
      return {
        render: function render(el, context, callback) {
          if (instance === null) {
            var type = el.type,
                props = el.props,
                ref = el.ref;

            var wrapperProps = _objectSpread({
              Component: type,
              props: props,
              wrappingComponentProps: wrappingComponentProps,
              context: context
            }, ref && {
              refProp: ref
            });

            var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread(_objectSpread({}, options), {}, {
              adapter: adapter
            }));

            var wrappedEl = /*#__PURE__*/_react["default"].createElement(ReactWrapperComponent, wrapperProps);

            instance = hydrateIn ? _reactDom["default"].hydrate(wrappedEl, domNode) : _reactDom["default"].render(wrappedEl, domNode);

            if (typeof callback === 'function') {
              callback();
            }
          } else {
            instance.setChildProps(el.props, context, callback);
          }
        },
        unmount: function unmount() {
          _reactDom["default"].unmountComponentAtNode(domNode);

          instance = null;
        },
        getNode: function getNode() {
          if (!instance) {
            return null;
          }

          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          var _ref = nodeHierarchy.find(function (x) {
            return x.instance && x.instance.componentDidCatch;
          }) || {},
              catchingInstance = _ref.instance;

          (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode);
        },
        simulateEvent: function simulateEvent(node, event, mock) {
          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
          var eventFn = _testUtils["default"].Simulate[mappedEvent];

          if (!eventFn) {
            throw new TypeError("ReactWrapper::simulate() event '".concat(event, "' does not exist"));
          } // eslint-disable-next-line react/no-find-dom-node


          eventFn(adapter.nodeToHostNode(node), mock);
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        getWrappingComponentRenderer: function getWrappingComponentRenderer() {
          return _objectSpread(_objectSpread({}, this), (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
            toTree: function toTree(inst) {
              return _toTree(inst._reactInternalFiber);
            },
            getMountWrapperInstance: function getMountWrapperInstance() {
              return instance;
            }
          }));
        }
      };
    }
  }, {
    key: "createShallowRenderer",
    value: function createShallowRenderer()
    /* options */
    {
      var adapter = this;
      var renderer = new _shallow["default"]();
      var isDOM = false;
      var cachedNode = null;
      return {
        render: function render(el, context) {
          var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref2$providerValues = _ref2.providerValues,
              providerValues = _ref2$providerValues === void 0 ? new Map() : _ref2$providerValues;

          cachedNode = el;
          /* eslint consistent-return: 0 */

          if (typeof el.type === 'string') {
            isDOM = true;
          } else if ((0, _reactIs.isContextProvider)(el)) {
            providerValues.set(el.type, el.props.value);
            var MockProvider = (0, _object["default"])(function (props) {
              return props.children;
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderer.render(_objectSpread(_objectSpread({}, el), {}, {
                type: MockProvider
              }));
            });
          } else if ((0, _reactIs.isContextConsumer)(el)) {
            var Provider = adapter.getProviderFromConsumer(el.type);
            var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
            var MockConsumer = (0, _object["default"])(function (props) {
              return props.children(value);
            }, el.type);
            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderer.render(_objectSpread(_objectSpread({}, el), {}, {
                type: MockConsumer
              }));
            });
          } else {
            isDOM = false;
            var Component = el.type;
            var isStateful = Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
            );

            if (!isStateful && typeof Component === 'function') {
              var wrappedEl = (0, _object["default"])(function () {
                return Component.apply(void 0, arguments);
              }, // eslint-disable-line new-cap
              Component);
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderer.render(_objectSpread(_objectSpread({}, el), {}, {
                  type: wrappedEl
                }), context);
              });
            }

            if (isStateful) {
              if (renderer._instance && el.props === renderer._instance.props && !(0, _enzymeShallowEqual["default"])(context, renderer._instance.context)) {
                var _spyMethod = (0, _enzymeAdapterUtils.spyMethod)(renderer, '_updateClassComponent', function (originalMethod) {
                  return function _updateClassComponent() {
                    var props = renderer._instance.props;

                    var clonedProps = _objectSpread({}, props);

                    renderer._instance.props = clonedProps;

                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }

                    var result = originalMethod.apply(renderer, args);
                    renderer._instance.props = props;
                    restore();
                    return result;
                  };
                }),
                    restore = _spyMethod.restore;
              }
            }

            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderer.render(el, context);
            });
          }
        },
        unmount: function unmount() {
          renderer.unmount();
        },
        getNode: function getNode() {
          if (isDOM) {
            return elementToTree(cachedNode);
          }

          var output = renderer.getRenderOutput();
          return {
            nodeType: nodeTypeFromType(cachedNode.type),
            type: cachedNode.type,
            props: cachedNode.props,
            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
            ref: cachedNode.ref,
            instance: renderer._instance,
            rendered: Array.isArray(output) ? flatten(output).map(function (el) {
              return elementToTree(el);
            }) : elementToTree(output)
          };
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode);
        },
        simulateEvent: function simulateEvent(node, event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];

          if (handler) {
            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              // TODO(lmr): create/use synthetic events
              // TODO(lmr): emulate React's event propagation
              // ReactDOM.unstable_batchedUpdates(() => {
              handler.apply(void 0, args); // });
            });
          }
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {
          return (0, _checkPropTypes2["default"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
          });
        }
      };
    }
  }, {
    key: "createStringRenderer",
    value: function createStringRenderer(options) {
      return {
        render: function render(el, context) {
          if (options.context && (el.type.contextTypes || options.childContextTypes)) {
            var childContextTypes = _objectSpread(_objectSpread({}, el.type.contextTypes || {}), options.childContextTypes);

            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
            return _server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(ContextWrapper));
          }

          return _server["default"].renderToStaticMarkup(el);
        }
      };
    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "createRenderer",
    value: function createRenderer(options) {
      switch (options.mode) {
        case _enzyme.EnzymeAdapter.MODES.MOUNT:
          return this.createMountRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.SHALLOW:
          return this.createShallowRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.STRING:
          return this.createStringRenderer(options);

        default:
          throw new Error("Enzyme Internal Error: Unrecognized mode: ".concat(options.mode));
      }
    }
  }, {
    key: "wrap",
    value: function wrap(element) {
      return (0, _enzymeAdapterUtils.wrap)(element);
    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "nodeToElement",
    value: function nodeToElement(node) {
      if (!node || _typeof(node) !== 'object') return null;
      return /*#__PURE__*/_react["default"].createElement(node.type, (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
    }
  }, {
    key: "elementToNode",
    value: function elementToNode(element) {
      return elementToTree(element);
    }
  }, {
    key: "nodeToHostNode",
    value: function nodeToHostNode(node) {
      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = _nodeToHostNode(node);

      if (Array.isArray(nodes) && !supportsArray) {
        return nodes[0];
      }

      return nodes;
    }
  }, {
    key: "displayNameOfNode",
    value: function displayNameOfNode(node) {
      if (!node) return null;
      var type = node.type,
          $$typeof = node.$$typeof;
      var nodeType = type || $$typeof; // newer node types may be undefined, so only test if the nodeType exists

      if (nodeType) {
        switch (nodeType) {
          case _reactIs.AsyncMode || NaN:
            return 'AsyncMode';

          case _reactIs.Fragment || NaN:
            return 'Fragment';

          case _reactIs.StrictMode || NaN:
            return 'StrictMode';

          case _reactIs.Portal || NaN:
            return 'Portal';

          default:
        }
      }

      var $$typeofType = type && type.$$typeof;

      switch ($$typeofType) {
        case _reactIs.ContextConsumer || NaN:
          return 'ContextConsumer';

        case _reactIs.ContextProvider || NaN:
          return 'ContextProvider';

        case _reactIs.ForwardRef || NaN:
          {
            if (type.displayName) {
              return type.displayName;
            }

            var name = (0, _enzymeAdapterUtils.displayNameOfNode)({
              type: type.render
            });
            return name ? "ForwardRef(".concat(name, ")") : 'ForwardRef';
          }

        default:
          return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
      }
    }
  }, {
    key: "isValidElement",
    value: function isValidElement(element) {
      return (0, _reactIs.isElement)(element);
    }
  }, {
    key: "isValidElementType",
    value: function isValidElementType(object) {
      return !!object && (0, _reactIs.isValidElementType)(object);
    }
  }, {
    key: "isFragment",
    value: function isFragment(fragment) {
      return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
    }
  }, {
    key: "isCustomComponent",
    value: function isCustomComponent(type) {
      var fakeElement = makeFakeElement(type);
      return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement));
    }
  }, {
    key: "isContextConsumer",
    value: function isContextConsumer(type) {
      return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
    }
  }, {
    key: "isCustomComponentElement",
    value: function isCustomComponentElement(inst) {
      if (!inst || !this.isValidElement(inst)) {
        return false;
      }

      return this.isCustomComponent(inst.type);
    }
  }, {
    key: "getProviderFromConsumer",
    value: function getProviderFromConsumer(Consumer) {
      var _ref3 = Consumer || {},
          Provider = _ref3.Provider;

      if (Provider) {
        return Provider;
      }

      throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
    }
  }, {
    key: "createElement",
    value: function createElement() {
      return /*#__PURE__*/_react["default"].createElement.apply(_react["default"], arguments);
    }
  }, {
    key: "wrapWithWrappingComponent",
    value: function wrapWithWrappingComponent(node, options) {
      return {
        RootFinder: _enzymeAdapterUtils.RootFinder,
        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react["default"].createElement, node, options)
      };
    }
  }]);

  return ReactSixteenThreeAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenThreeAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIuanMiXSwibmFtZXMiOlsiSG9zdFJvb3QiLCJDbGFzc0NvbXBvbmVudCIsIkZyYWdtZW50VHlwZSIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lclR5cGUiLCJDb250ZXh0UHJvdmlkZXJUeXBlIiwiRm9yd2FyZFJlZlR5cGUiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwiZWxlbWVudFRvVHJlZSIsImNoaWxkcmVuIiwiY29udGFpbmVySW5mbyIsInByb3BzIiwibm9kZVR5cGUiLCJrZXkiLCJyZWYiLCJpbnN0YW5jZSIsInJlbmRlcmVkIiwidG9UcmVlIiwidm5vZGUiLCJ0YWciLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwic3RhdGVOb2RlIiwibWVtb2l6ZWRQcm9wcyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJwZW5kaW5nUHJvcHMiLCJFcnJvciIsIm5vZGVUb0hvc3ROb2RlIiwiX25vZGUiLCJtYXBwZXIiLCJpdGVtIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImdldFByb3ZpZGVyRGVmYXVsdFZhbHVlIiwiUHJvdmlkZXIiLCJfY29udGV4dCIsIl9kZWZhdWx0VmFsdWUiLCJtYWtlRmFrZUVsZW1lbnQiLCIkJHR5cGVvZiIsIkVsZW1lbnQiLCJldmVudE9wdGlvbnMiLCJhbmltYXRpb24iLCJSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIiLCJsaWZlY3ljbGVzIiwib3B0aW9ucyIsImVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUiLCJsZWdhY3lDb250ZXh0TW9kZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9uU2V0U3RhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWciLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNldFN0YXRlIiwic2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2giLCJnZXRDaGlsZENvbnRleHQiLCJjYWxsZWRCeVJlbmRlcmVyIiwiYXR0YWNoVG8iLCJoeWRyYXRlSW4iLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwiZG9tTm9kZSIsImdsb2JhbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFkYXB0ZXIiLCJyZW5kZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJDb21wb25lbnQiLCJyZWZQcm9wIiwiUmVhY3RXcmFwcGVyQ29tcG9uZW50Iiwid3JhcHBlZEVsIiwiUmVhY3QiLCJoeWRyYXRlIiwic2V0Q2hpbGRQcm9wcyIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiZ2V0Tm9kZSIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsInNpbXVsYXRlRXJyb3IiLCJub2RlSGllcmFyY2h5Iiwicm9vdE5vZGUiLCJlcnJvciIsImZpbmQiLCJ4IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjYXRjaGluZ0luc3RhbmNlIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJzaW11bGF0ZUV2ZW50IiwiZXZlbnQiLCJtb2NrIiwibWFwcGVkRXZlbnQiLCJldmVudEZuIiwiVGVzdFV0aWxzIiwiU2ltdWxhdGUiLCJUeXBlRXJyb3IiLCJiYXRjaGVkVXBkYXRlcyIsImZuIiwiZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlciIsImluc3QiLCJnZXRNb3VudFdyYXBwZXJJbnN0YW5jZSIsInJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwiaXNET00iLCJjYWNoZWROb2RlIiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJzZXQiLCJ2YWx1ZSIsIk1vY2tQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwiaGFzIiwiZ2V0IiwiTW9ja0NvbnN1bWVyIiwiaXNTdGF0ZWZ1bCIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsIl9pbnN0YW5jZSIsIm9yaWdpbmFsTWV0aG9kIiwiX3VwZGF0ZUNsYXNzQ29tcG9uZW50IiwiY2xvbmVkUHJvcHMiLCJhcmdzIiwiYXBwbHkiLCJyZXN0b3JlIiwib3V0cHV0IiwiZ2V0UmVuZGVyT3V0cHV0IiwiY29uY2F0IiwiaGFuZGxlciIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJoaWVyYXJjaHkiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsIkNvbnRleHRXcmFwcGVyIiwiUmVhY3RET01TZXJ2ZXIiLCJyZW5kZXJUb1N0YXRpY01hcmt1cCIsIm1vZGUiLCJFbnp5bWVBZGFwdGVyIiwiTU9ERVMiLCJNT1VOVCIsImNyZWF0ZU1vdW50UmVuZGVyZXIiLCJTSEFMTE9XIiwiY3JlYXRlU2hhbGxvd1JlbmRlcmVyIiwiU1RSSU5HIiwiY3JlYXRlU3RyaW5nUmVuZGVyZXIiLCJlbGVtZW50Iiwic3VwcG9ydHNBcnJheSIsIm5vZGVzIiwiQXN5bmNNb2RlIiwiTmFOIiwiRnJhZ21lbnQiLCJTdHJpY3RNb2RlIiwiJCR0eXBlb2ZUeXBlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsImRpc3BsYXlOYW1lIiwibmFtZSIsIm9iamVjdCIsImZyYWdtZW50IiwiZmFrZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIkNvbnN1bWVyIiwiUm9vdEZpbmRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQTs7QUFDQTs7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WEEsUUFBUSxJQUFJLEVBREQ7QUFBQSxVQUN4QnBJLFFBRHdCLFNBQ3hCQSxRQUR3Qjs7QUFFaEMsVUFBSUEsUUFBSixFQUFjO0FBQ1osZUFBT0EsUUFBUDtBQUNEOztBQUNELFlBQU0sSUFBSVIsS0FBSixDQUFVLDJFQUFWLENBQU47QUFDRDs7O29DQUVzQjtBQUNyQiwwQkFBTzhDLGtCQUFNVixhQUFOLG9DQUFQO0FBQ0Q7Ozs4Q0FFeUJ4RSxJLEVBQU1zRCxPLEVBQVM7QUFDdkMsYUFBTztBQUNMMkgsUUFBQUEsVUFBVSxFQUFWQSw4QkFESztBQUVMakwsUUFBQUEsSUFBSSxFQUFFLG1EQUEwQmtGLGtCQUFNVixhQUFoQyxFQUErQ3hFLElBQS9DLEVBQXFEc0QsT0FBckQ7QUFGRCxPQUFQO0FBSUQ7Ozs7RUExWG9DaUcscUI7O0FBNlh2QzJCLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQi9ILHdCQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgUmVhY3RET01TZXJ2ZXIgZnJvbSAncmVhY3QtZG9tL3NlcnZlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBTaGFsbG93UmVuZGVyZXIgZnJvbSAncmVhY3QtdGVzdC1yZW5kZXJlci9zaGFsbG93Jztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFRlc3RVdGlscyBmcm9tICdyZWFjdC1kb20vdGVzdC11dGlscyc7XG5pbXBvcnQgY2hlY2tQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcyc7XG5pbXBvcnQge1xuICBBc3luY01vZGUsXG4gIENvbnRleHRDb25zdW1lcixcbiAgQ29udGV4dFByb3ZpZGVyLFxuICBFbGVtZW50LFxuICBGb3J3YXJkUmVmLFxuICBGcmFnbWVudCxcbiAgaXNDb250ZXh0Q29uc3VtZXIsXG4gIGlzQ29udGV4dFByb3ZpZGVyLFxuICBpc0VsZW1lbnQsXG4gIGlzRm9yd2FyZFJlZixcbiAgaXNQb3J0YWwsXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcbiAgUG9ydGFsLFxuICBTdHJpY3RNb2RlLFxufSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgeyBFbnp5bWVBZGFwdGVyIH0gZnJvbSAnZW56eW1lJztcbmltcG9ydCB7IHR5cGVPZk5vZGUgfSBmcm9tICdlbnp5bWUvYnVpbGQvVXRpbHMnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICdlbnp5bWUtc2hhbGxvdy1lcXVhbCc7XG5pbXBvcnQge1xuICBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgZWxlbWVudFRvVHJlZSBhcyB1dGlsRWxlbWVudFRvVHJlZSxcbiAgbm9kZVR5cGVGcm9tVHlwZSBhcyB1dGlsTm9kZVR5cGVGcm9tVHlwZSxcbiAgbWFwTmF0aXZlRXZlbnROYW1lcyxcbiAgcHJvcEZyb21FdmVudCxcbiAgYXNzZXJ0RG9tQXZhaWxhYmxlLFxuICB3aXRoU2V0U3RhdGVBbGxvd2VkLFxuICBjcmVhdGVSZW5kZXJXcmFwcGVyLFxuICBjcmVhdGVNb3VudFdyYXBwZXIsXG4gIHByb3BzV2l0aEtleXNBbmRSZWYsXG4gIGVuc3VyZUtleU9yVW5kZWZpbmVkLFxuICBzaW11bGF0ZUVycm9yLFxuICB3cmFwLFxuICBnZXRDb21wb25lbnRTdGFjayxcbiAgUm9vdEZpbmRlcixcbiAgZ2V0Tm9kZUZyb21Sb290RmluZGVyLFxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50LFxuICBnZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIsXG4gIHNweU1ldGhvZCxcbn0gZnJvbSAnZW56eW1lLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IHsgZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGggfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3JlZmxlY3Rpb24nO1xuXG5jb25zdCBIb3N0Um9vdCA9IDM7XG5jb25zdCBDbGFzc0NvbXBvbmVudCA9IDI7XG5jb25zdCBGcmFnbWVudFR5cGUgPSAxMDtcbmNvbnN0IEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xuY29uc3QgSG9zdFBvcnRhbCA9IDQ7XG5jb25zdCBIb3N0Q29tcG9uZW50ID0gNTtcbmNvbnN0IEhvc3RUZXh0ID0gNjtcbmNvbnN0IE1vZGUgPSAxMTtcbmNvbnN0IENvbnRleHRDb25zdW1lclR5cGUgPSAxMjtcbmNvbnN0IENvbnRleHRQcm92aWRlclR5cGUgPSAxMztcbmNvbnN0IEZvcndhcmRSZWZUeXBlID0gMTQ7XG5cbmZ1bmN0aW9uIG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGVXaXRoU2libGluZykge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBsZXQgbm9kZSA9IG5vZGVXaXRoU2libGluZztcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGFycmF5LnB1c2gobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IFt7IGk6IDAsIGFycmF5OiBhcnIgfV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG4gICAgd2hpbGUgKG4uaSA8IG4uYXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbCA9IG4uYXJyYXlbbi5pXTtcbiAgICAgIG4uaSArPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobik7XG4gICAgICAgIHN0YWNrLnB1c2goeyBpOiAwLCBhcnJheTogZWwgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub2RlVHlwZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFBvcnRhbCkge1xuICAgIHJldHVybiAncG9ydGFsJztcbiAgfVxuXG4gIHJldHVybiB1dGlsTm9kZVR5cGVGcm9tVHlwZSh0eXBlKTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFRvVHJlZShlbCkge1xuICBpZiAoIWlzUG9ydGFsKGVsKSkge1xuICAgIHJldHVybiB1dGlsRWxlbWVudFRvVHJlZShlbCwgZWxlbWVudFRvVHJlZSk7XG4gIH1cblxuICBjb25zdCB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH0gPSBlbDtcbiAgY29uc3QgcHJvcHMgPSB7IGNoaWxkcmVuLCBjb250YWluZXJJbmZvIH07XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlVHlwZTogJ3BvcnRhbCcsXG4gICAgdHlwZTogUG9ydGFsLFxuICAgIHByb3BzLFxuICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoZWwua2V5KSxcbiAgICByZWY6IGVsLnJlZiB8fCBudWxsLFxuICAgIGluc3RhbmNlOiBudWxsLFxuICAgIHJlbmRlcmVkOiBlbGVtZW50VG9UcmVlKGVsLmNoaWxkcmVuKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9UcmVlKHZub2RlKSB7XG4gIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVE9ETyhsbXIpOiBJJ20gbm90IHJlYWxseSBzdXJlIEkgdW5kZXJzdGFuZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHdoYXRcbiAgLy8gaSBzaG91bGQgYmUgZG9pbmcsIG9yIGlmIHRoaXMgaXMgYSBoYWNrIGZvciBzb21ldGhpbmcgaSdtIGRvaW5nIHdyb25nXG4gIC8vIHNvbWV3aGVyZSBlbHNlLiBTaG91bGQgdGFsayB0byBzZWJhc3RpYW4gYWJvdXQgdGhpcyBwZXJoYXBzXG4gIGNvbnN0IG5vZGUgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCh2bm9kZSk7XG4gIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OiAvLyAzXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XG4gICAgY2FzZSBIb3N0UG9ydGFsOiB7IC8vIDRcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhdGVOb2RlOiB7IGNvbnRhaW5lckluZm8gfSxcbiAgICAgICAgbWVtb2l6ZWRQcm9wczogY2hpbGRyZW4sXG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGNvbnN0IHByb3BzID0geyBjb250YWluZXJJbmZvLCBjaGlsZHJlbiB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxuICAgICAgICB0eXBlOiBQb3J0YWwsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2NsYXNzJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxuICAgICAgfTtcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6IC8vIDFcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OiB7IC8vIDVcbiAgICAgIGxldCByZW5kZXJlZE5vZGVzID0gZmxhdHRlbihub2RlQW5kU2libGluZ3NBcnJheShub2RlLmNoaWxkKS5tYXAodG9UcmVlKSk7XG4gICAgICBpZiAocmVuZGVyZWROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVuZGVyZWROb2RlcyA9IFtub2RlLm1lbW9pemVkUHJvcHMuY2hpbGRyZW5dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdob3N0JyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBub2RlLnN0YXRlTm9kZSxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkTm9kZXMsXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OiAvLyA2XG4gICAgICByZXR1cm4gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgIGNhc2UgRnJhZ21lbnRUeXBlOiAvLyAxMFxuICAgIGNhc2UgTW9kZTogLy8gMTFcbiAgICBjYXNlIENvbnRleHRQcm92aWRlclR5cGU6IC8vIDEzXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXJUeXBlOiAvLyAxMlxuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgRm9yd2FyZFJlZlR5cGU6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUucGVuZGluZ1Byb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpLFxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiB1bmtub3duIG5vZGUgd2l0aCB0YWcgJHtub2RlLnRhZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlblRvVHJlZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZSk7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRvVHJlZShjaGlsZHJlblswXSk7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW4oY2hpbGRyZW4ubWFwKHRvVHJlZSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9Ib3N0Tm9kZShfbm9kZSkge1xuICAvLyBOT1RFKGxtcik6IG5vZGUgY291bGQgYmUgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgLy8gd2hpY2ggd29udCBoYXZlIGFuIGluc3RhbmNlIHByb3AsIGJ1dCB3ZSBjYW4gZ2V0IHRoZVxuICAvLyBob3N0IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUgYXQgdGhhdCBwb2ludC5cbiAgLy8gQWx0aG91Z2ggdGhpcyBicmVha3MgZG93biBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5LFxuICAvLyBhcyBpcyBwb3NzaWJsZSB3aXRoIFJlYWN0IDE2LlxuICBsZXQgbm9kZSA9IF9ub2RlO1xuICB3aGlsZSAobm9kZSAmJiAhQXJyYXkuaXNBcnJheShub2RlKSAmJiBub2RlLmluc3RhbmNlID09PSBudWxsKSB7XG4gICAgbm9kZSA9IG5vZGUucmVuZGVyZWQ7XG4gIH1cbiAgLy8gaWYgdGhlIFNGQyByZXR1cm5lZCBudWxsIGVmZmVjdGl2ZWx5LCB0aGVyZSBpcyBubyBob3N0IG5vZGUuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFwcGVyID0gKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmluc3RhbmNlKSByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUoaXRlbS5pbnN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKG1hcHBlcik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5yZW5kZXJlZCkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gJ2NsYXNzJykge1xuICAgIHJldHVybiBub2RlLnJlbmRlcmVkLm1hcChtYXBwZXIpO1xuICB9XG4gIHJldHVybiBtYXBwZXIobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKSB7XG4gIC8vIFJlYWN0IHN0b3JlcyByZWZlcmVuY2VzIHRvIHRoZSBQcm92aWRlcidzIGRlZmF1bHRWYWx1ZSBkaWZmZXJlbnRseSBhY3Jvc3MgdmVyc2lvbnMuXG4gIGlmICgnX2RlZmF1bHRWYWx1ZScgaW4gUHJvdmlkZXIuX2NvbnRleHQpIHtcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0VuenltZSBJbnRlcm5hbCBFcnJvcjogY2Fu4oCZdCBmaWd1cmUgb3V0IGhvdyB0byBnZXQgUHJvdmlkZXLigJlzIGRlZmF1bHQgdmFsdWUnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZha2VFbGVtZW50KHR5cGUpIHtcbiAgcmV0dXJuIHsgJCR0eXBlb2Y6IEVsZW1lbnQsIHR5cGUgfTtcbn1cblxuY29uc3QgZXZlbnRPcHRpb25zID0geyBhbmltYXRpb246IHRydWUgfTtcblxuY2xhc3MgUmVhY3RTaXh0ZWVuVGhyZWVBZGFwdGVyIGV4dGVuZHMgRW56eW1lQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgeyBsaWZlY3ljbGVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZTogdHJ1ZSwgLy8gVE9ETzogcmVtb3ZlLCBzZW12ZXItbWFqb3JcbiAgICAgIGxlZ2FjeUNvbnRleHRNb2RlOiAncGFyZW50JyxcbiAgICAgIGxpZmVjeWNsZXM6IHtcbiAgICAgICAgLi4ubGlmZWN5Y2xlcyxcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiB7XG4gICAgICAgICAgb25TZXRTdGF0ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB7XG4gICAgICAgICAgaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgc2V0U3RhdGU6IHtcbiAgICAgICAgICBza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XG4gICAgICAgICAgY2FsbGVkQnlSZW5kZXJlcjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBhc3NlcnREb21BdmFpbGFibGUoJ21vdW50Jyk7XG4gICAgY29uc3QgeyBhdHRhY2hUbywgaHlkcmF0ZUluLCB3cmFwcGluZ0NvbXBvbmVudFByb3BzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRvbU5vZGUgPSBoeWRyYXRlSW4gfHwgYXR0YWNoVG8gfHwgZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBpbnN0YW5jZSA9IG51bGw7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmIH0gPSBlbDtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgLi4uKHJlZiAmJiB7IHJlZlByb3A6IHJlZiB9KSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IFJlYWN0V3JhcHBlckNvbXBvbmVudCA9IGNyZWF0ZU1vdW50V3JhcHBlcihlbCwgeyAuLi5vcHRpb25zLCBhZGFwdGVyIH0pO1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RXcmFwcGVyQ29tcG9uZW50LCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICAgIGluc3RhbmNlID0gaHlkcmF0ZUluXG4gICAgICAgICAgICA/IFJlYWN0RE9NLmh5ZHJhdGUod3JhcHBlZEVsLCBkb21Ob2RlKVxuICAgICAgICAgICAgOiBSZWFjdERPTS5yZW5kZXIod3JhcHBlZEVsLCBkb21Ob2RlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZS5zZXRDaGlsZFByb3BzKGVsLnByb3BzLCBjb250ZXh0LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKGRvbU5vZGUpO1xuICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXROb2RlRnJvbVJvb3RGaW5kZXIoXG4gICAgICAgICAgYWRhcHRlci5pc0N1c3RvbUNvbXBvbmVudCxcbiAgICAgICAgICB0b1RyZWUoaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxGaWJlciksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlOiBjYXRjaGluZ0luc3RhbmNlIH0gPSBub2RlSGllcmFyY2h5XG4gICAgICAgICAgLmZpbmQoKHgpID0+IHguaW5zdGFuY2UgJiYgeC5pbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCkgfHwge307XG5cbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBjYXRjaGluZ0luc3RhbmNlLFxuICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHksXG4gICAgICAgICAgbm9kZVR5cGVGcm9tVHlwZSxcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRXZlbnQgPSBtYXBOYXRpdmVFdmVudE5hbWVzKGV2ZW50LCBldmVudE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBldmVudEZuID0gVGVzdFV0aWxzLlNpbXVsYXRlW21hcHBlZEV2ZW50XTtcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVhY3RXcmFwcGVyOjpzaW11bGF0ZSgpIGV2ZW50ICcke2V2ZW50fScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZmluZC1kb20tbm9kZVxuICAgICAgICBldmVudEZuKGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUobm9kZSksIG1vY2spO1xuICAgICAgfSxcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xuICAgICAgfSxcbiAgICAgIGdldFdyYXBwaW5nQ29tcG9uZW50UmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAuLi5nZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIoe1xuICAgICAgICAgICAgdG9UcmVlOiAoaW5zdCkgPT4gdG9UcmVlKGluc3QuX3JlYWN0SW50ZXJuYWxGaWJlciksXG4gICAgICAgICAgICBnZXRNb3VudFdyYXBwZXJJbnN0YW5jZTogKCkgPT4gaW5zdGFuY2UsXG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVTaGFsbG93UmVuZGVyZXIoLyogb3B0aW9ucyAqLykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFNoYWxsb3dSZW5kZXJlcigpO1xuICAgIGxldCBpc0RPTSA9IGZhbHNlO1xuICAgIGxldCBjYWNoZWROb2RlID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0LCB7XG4gICAgICAgIHByb3ZpZGVyVmFsdWVzID0gbmV3IE1hcCgpLFxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNhY2hlZE5vZGUgPSBlbDtcbiAgICAgICAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXG4gICAgICAgIGlmICh0eXBlb2YgZWwudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc0RPTSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0UHJvdmlkZXIoZWwpKSB7XG4gICAgICAgICAgcHJvdmlkZXJWYWx1ZXMuc2V0KGVsLnR5cGUsIGVsLnByb3BzLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBNb2NrUHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgKHByb3BzKSA9PiBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIGVsLnR5cGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogTW9ja1Byb3ZpZGVyIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbnRleHRDb25zdW1lcihlbCkpIHtcbiAgICAgICAgICBjb25zdCBQcm92aWRlciA9IGFkYXB0ZXIuZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoZWwudHlwZSk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlclZhbHVlcy5oYXMoUHJvdmlkZXIpXG4gICAgICAgICAgICA/IHByb3ZpZGVyVmFsdWVzLmdldChQcm92aWRlcilcbiAgICAgICAgICAgIDogZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpO1xuICAgICAgICAgIGNvbnN0IE1vY2tDb25zdW1lciA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAocHJvcHMpID0+IHByb3BzLmNoaWxkcmVuKHZhbHVlKSxcbiAgICAgICAgICAgIGVsLnR5cGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogTW9ja0NvbnN1bWVyIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0RPTSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50IH0gPSBlbDtcblxuICAgICAgICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBDb21wb25lbnQucHJvdG90eXBlICYmIChcbiAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgICAgICAgICAgfHwgQXJyYXkuaXNBcnJheShDb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMpIC8vIGZhbGxiYWNrIGZvciBjcmVhdGVDbGFzcyBjb21wb25lbnRzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghaXNTdGF0ZWZ1bCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkRWwgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAoLi4uYXJncykgPT4gQ29tcG9uZW50KC4uLmFyZ3MpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcih7IC4uLmVsLCB0eXBlOiB3cmFwcGVkRWwgfSwgY29udGV4dCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJlbmRlcmVyLl9pbnN0YW5jZVxuICAgICAgICAgICAgICAmJiBlbC5wcm9wcyA9PT0gcmVuZGVyZXIuX2luc3RhbmNlLnByb3BzXG4gICAgICAgICAgICAgICYmICFzaGFsbG93RXF1YWwoY29udGV4dCwgcmVuZGVyZXIuX2luc3RhbmNlLmNvbnRleHQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgeyByZXN0b3JlIH0gPSBzcHlNZXRob2QoXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgICAgJ191cGRhdGVDbGFzc0NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgKG9yaWdpbmFsTWV0aG9kKSA9PiBmdW5jdGlvbiBfdXBkYXRlQ2xhc3NDb21wb25lbnQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gcmVuZGVyZXIuX2luc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkUHJvcHMgPSB7IC4uLnByb3BzIH07XG4gICAgICAgICAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UucHJvcHMgPSBjbG9uZWRQcm9wcztcblxuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWxNZXRob2QuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgIHJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcihlbCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgcmVuZGVyZXIudW5tb3VudCgpO1xuICAgICAgfSxcbiAgICAgIGdldE5vZGUoKSB7XG4gICAgICAgIGlmIChpc0RPTSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJlbmRlcmVyLmdldFJlbmRlck91dHB1dCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGVUeXBlOiBub2RlVHlwZUZyb21UeXBlKGNhY2hlZE5vZGUudHlwZSksXG4gICAgICAgICAgdHlwZTogY2FjaGVkTm9kZS50eXBlLFxuICAgICAgICAgIHByb3BzOiBjYWNoZWROb2RlLnByb3BzLFxuICAgICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQoY2FjaGVkTm9kZS5rZXkpLFxuICAgICAgICAgIHJlZjogY2FjaGVkTm9kZS5yZWYsXG4gICAgICAgICAgaW5zdGFuY2U6IHJlbmRlcmVyLl9pbnN0YW5jZSxcbiAgICAgICAgICByZW5kZXJlZDogQXJyYXkuaXNBcnJheShvdXRwdXQpXG4gICAgICAgICAgICA/IGZsYXR0ZW4ob3V0cHV0KS5tYXAoKGVsKSA9PiBlbGVtZW50VG9UcmVlKGVsKSlcbiAgICAgICAgICAgIDogZWxlbWVudFRvVHJlZShvdXRwdXQpLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXJyb3Iobm9kZUhpZXJhcmNoeSwgcm9vdE5vZGUsIGVycm9yKSB7XG4gICAgICAgIHNpbXVsYXRlRXJyb3IoXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcmVuZGVyZXIuX2luc3RhbmNlLFxuICAgICAgICAgIGNhY2hlZE5vZGUsXG4gICAgICAgICAgbm9kZUhpZXJhcmNoeS5jb25jYXQoY2FjaGVkTm9kZSksXG4gICAgICAgICAgbm9kZVR5cGVGcm9tVHlwZSxcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5vZGUucHJvcHNbcHJvcEZyb21FdmVudChldmVudCwgZXZlbnRPcHRpb25zKV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGNyZWF0ZS91c2Ugc3ludGhldGljIGV2ZW50c1xuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBlbXVsYXRlIFJlYWN0J3MgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgIC8vIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgaGllcmFyY2h5KSB7XG4gICAgICAgIHJldHVybiBjaGVja1Byb3BUeXBlcyhcbiAgICAgICAgICB0eXBlU3BlY3MsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIGRpc3BsYXlOYW1lT2ZOb2RlKGNhY2hlZE5vZGUpLFxuICAgICAgICAgICgpID0+IGdldENvbXBvbmVudFN0YWNrKGhpZXJhcmNoeS5jb25jYXQoW2NhY2hlZE5vZGVdKSksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVTdHJpbmdSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0ICYmIChlbC50eXBlLmNvbnRleHRUeXBlcyB8fCBvcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgLi4uKGVsLnR5cGUuY29udGV4dFR5cGVzIHx8IHt9KSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBDb250ZXh0V3JhcHBlciA9IGNyZWF0ZVJlbmRlcldyYXBwZXIoZWwsIGNvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0V3JhcHBlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cChlbCk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvLyBQcm92aWRlZCBhIGJhZyBvZiBvcHRpb25zLCByZXR1cm4gYW4gYEVuenltZVJlbmRlcmVyYC4gU29tZSBvcHRpb25zIGNhbiBiZSBpbXBsZW1lbnRhdGlvblxuICAvLyBzcGVjaWZpYywgbGlrZSBgYXR0YWNoYCBldGMuIGZvciBSZWFjdCwgYnV0IG5vdCBwYXJ0IG9mIHRoaXMgaW50ZXJmYWNlIGV4cGxpY2l0bHkuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCBuby11bnVzZWQtdmFyc1xuICBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLm1vZGUpIHtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5NT1VOVDogcmV0dXJuIHRoaXMuY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5TSEFMTE9XOiByZXR1cm4gdGhpcy5jcmVhdGVTaGFsbG93UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU1RSSU5HOiByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmdSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiBVbnJlY29nbml6ZWQgbW9kZTogJHtvcHRpb25zLm1vZGV9YCk7XG4gICAgfVxuICB9XG5cbiAgd3JhcChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHdyYXAoZWxlbWVudCk7XG4gIH1cblxuICAvLyBjb252ZXJ0cyBhbiBSU1ROb2RlIHRvIHRoZSBjb3JyZXNwb25kaW5nIEpTWCBQcmFnbWEgRWxlbWVudC4gVGhpcyB3aWxsIGJlIG5lZWRlZFxuICAvLyBpbiBvcmRlciB0byBpbXBsZW1lbnQgdGhlIGBXcmFwcGVyLm1vdW50KClgIGFuZCBgV3JhcHBlci5zaGFsbG93KClgIG1ldGhvZHMsIGJ1dCBzaG91bGRcbiAgLy8gYmUgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZCBmb3IgcGVvcGxlIHRvIGltcGxlbWVudC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsIG5vLXVudXNlZC12YXJzXG4gIG5vZGVUb0VsZW1lbnQobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KG5vZGUudHlwZSwgcHJvcHNXaXRoS2V5c0FuZFJlZihub2RlKSk7XG4gIH1cblxuICBlbGVtZW50VG9Ob2RlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFRvVHJlZShlbGVtZW50KTtcbiAgfVxuXG4gIG5vZGVUb0hvc3ROb2RlKG5vZGUsIHN1cHBvcnRzQXJyYXkgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVzID0gbm9kZVRvSG9zdE5vZGUobm9kZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpICYmICFzdXBwb3J0c0FycmF5KSB7XG4gICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgdHlwZSwgJCR0eXBlb2YgfSA9IG5vZGU7XG5cbiAgICBjb25zdCBub2RlVHlwZSA9IHR5cGUgfHwgJCR0eXBlb2Y7XG5cbiAgICAvLyBuZXdlciBub2RlIHR5cGVzIG1heSBiZSB1bmRlZmluZWQsIHNvIG9ubHkgdGVzdCBpZiB0aGUgbm9kZVR5cGUgZXhpc3RzXG4gICAgaWYgKG5vZGVUeXBlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgQXN5bmNNb2RlIHx8IE5hTjogcmV0dXJuICdBc3luY01vZGUnO1xuICAgICAgICBjYXNlIEZyYWdtZW50IHx8IE5hTjogcmV0dXJuICdGcmFnbWVudCc7XG4gICAgICAgIGNhc2UgU3RyaWN0TW9kZSB8fCBOYU46IHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICAgIGNhc2UgUG9ydGFsIHx8IE5hTjogcmV0dXJuICdQb3J0YWwnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lciB8fCBOYU46IHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyIHx8IE5hTjogcmV0dXJuICdDb250ZXh0UHJvdmlkZXInO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmIHx8IE5hTjoge1xuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXNwbGF5TmFtZU9mTm9kZSh7IHR5cGU6IHR5cGUucmVuZGVyIH0pO1xuICAgICAgICByZXR1cm4gbmFtZSA/IGBGb3J3YXJkUmVmKCR7bmFtZX0pYCA6ICdGb3J3YXJkUmVmJztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHJldHVybiBkaXNwbGF5TmFtZU9mTm9kZShub2RlKTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIGlzVmFsaWRFbGVtZW50VHlwZShvYmplY3QpIHtcbiAgICByZXR1cm4gISFvYmplY3QgJiYgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCk7XG4gIH1cblxuICBpc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIHR5cGVPZk5vZGUoZnJhZ21lbnQpID09PSBGcmFnbWVudDtcbiAgfVxuXG4gIGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUpIHtcbiAgICBjb25zdCBmYWtlRWxlbWVudCA9IG1ha2VGYWtlRWxlbWVudCh0eXBlKTtcbiAgICByZXR1cm4gISF0eXBlICYmIChcbiAgICAgIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nXG4gICAgICB8fCBpc0ZvcndhcmRSZWYoZmFrZUVsZW1lbnQpXG4gICAgICB8fCBpc0NvbnRleHRQcm92aWRlcihmYWtlRWxlbWVudClcbiAgICAgIHx8IGlzQ29udGV4dENvbnN1bWVyKGZha2VFbGVtZW50KVxuICAgICk7XG4gIH1cblxuICBpc0NvbnRleHRDb25zdW1lcih0eXBlKSB7XG4gICAgcmV0dXJuICEhdHlwZSAmJiBpc0NvbnRleHRDb25zdW1lcihtYWtlRmFrZUVsZW1lbnQodHlwZSkpO1xuICB9XG5cbiAgaXNDdXN0b21Db21wb25lbnRFbGVtZW50KGluc3QpIHtcbiAgICBpZiAoIWluc3QgfHwgIXRoaXMuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNDdXN0b21Db21wb25lbnQoaW5zdC50eXBlKTtcbiAgfVxuXG4gIGdldFByb3ZpZGVyRnJvbUNvbnN1bWVyKENvbnN1bWVyKSB7XG4gICAgY29uc3QgeyBQcm92aWRlciB9ID0gQ29uc3VtZXIgfHwge307XG4gICAgaWYgKFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gUHJvdmlkZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lIEludGVybmFsIEVycm9yOiBjYW7igJl0IGZpZ3VyZSBvdXQgaG93IHRvIGdldCBQcm92aWRlciBmcm9tIENvbnN1bWVyJyk7XG4gIH1cblxuICBjcmVhdGVFbGVtZW50KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCguLi5hcmdzKTtcbiAgfVxuXG4gIHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBSb290RmluZGVyLFxuICAgICAgbm9kZTogd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChSZWFjdC5jcmVhdGVFbGVtZW50LCBub2RlLCBvcHRpb25zKSxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTaXh0ZWVuVGhyZWVBZGFwdGVyO1xuIl19
//# sourceMappingURL=ReactSixteenThreeAdapter.js.map